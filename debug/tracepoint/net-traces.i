net-traces.i:60712:
extern struct tracepoint __tracepoint_net_dev_xmit; static inline __attribute__((unused)) __attribute__((no_instrument_function)) void trace_net_dev_xmit(struct sk_buff *skb, int rc, struct net_device *dev, unsigned int skb_len) { if (static_key_false(&__tracepoint_net_dev_xmit.key)) do { struct tracepoint_func *it_func_ptr; void *it_func; void *__data; if (!(cpumask_test_cpu(((({ typeof(cpu_number) pscr_ret__; do { const void *__vpp_verify = (typeof((&(cpu_number)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(cpu_number)) { case 1: pscr_ret__ = ({ typeof(cpu_number) pfo_ret__; switch (sizeof(cpu_number)) { case 1: asm("mov" "b ""%%""gs"":" "%" "1"",%0" : "=q" (pfo_ret__) : "m" (cpu_number)); break; case 2: asm("mov" "w ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 4: asm("mov" "l ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 8: asm("mov" "q ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; default: __bad_percpu_size(); } pfo_ret__; }); break; case 2: pscr_ret__ = ({ typeof(cpu_number) pfo_ret__; switch (sizeof(cpu_number)) { case 1: asm("mov" "b ""%%""gs"":" "%" "1"",%0" : "=q" (pfo_ret__) : "m" (cpu_number)); break; case 2: asm("mov" "w ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 4: asm("mov" "l ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 8: asm("mov" "q ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; default: __bad_percpu_size(); } pfo_ret__; }); break; case 4: pscr_ret__ = ({ typeof(cpu_number) pfo_ret__; switch (sizeof(cpu_number)) { case 1: asm("mov" "b ""%%""gs"":" "%" "1"",%0" : "=q" (pfo_ret__) : "m" (cpu_number)); break; case 2: asm("mov" "w ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 4: asm("mov" "l ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 8: asm("mov" "q ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; default: __bad_percpu_size(); } pfo_ret__; }); break; case 8: pscr_ret__ = ({ typeof(cpu_number) pfo_ret__; switch (sizeof(cpu_number)) { case 1: asm("mov" "b ""%%""gs"":" "%" "1"",%0" : "=q" (pfo_ret__) : "m" (cpu_number)); break; case 2: asm("mov" "w ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 4: asm("mov" "l ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 8: asm("mov" "q ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; default: __bad_percpu_size(); } pfo_ret__; }); break; default: __bad_size_call_parameter(); break; } pscr_ret__; }))), cpu_online_mask))) return; ; rcu_read_lock_sched_notrace(); it_func_ptr = ({ typeof(*((&__tracepoint_net_dev_xmit)->funcs)) *________p1 = (typeof(*((&__tracepoint_net_dev_xmit)->funcs)) *)({ typeof(((&__tracepoint_net_dev_xmit)->funcs)) _________p1 = ({ union { typeof(((&__tracepoint_net_dev_xmit)->funcs)) __val; char __c[1]; } __u; if (1) __read_once_size(&(((&__tracepoint_net_dev_xmit)->funcs)), __u.__c, sizeof(((&__tracepoint_net_dev_xmit)->funcs))); else __read_once_size_nocheck(&(((&__tracepoint_net_dev_xmit)->funcs)), __u.__c, sizeof(((&__tracepoint_net_dev_xmit)->funcs))); __u.__val; }); do { } while (0); (_________p1); }); do { } while (0); ; ((typeof(*((&__tracepoint_net_dev_xmit)->funcs)) *)(________p1)); }); if (it_func_ptr) { do { it_func = (it_func_ptr)->func; __data = (it_func_ptr)->data; ((void(*)(void *__data, struct sk_buff *skb, int rc, struct net_device *dev, unsigned int skb_len))(it_func))(__data, skb, rc, dev, skb_len); } while ((++it_func_ptr)->func); } rcu_read_unlock_sched_notrace(); ; } while (0); if ((0 || 0) && (cpumask_test_cpu(((({ typeof(cpu_number) pscr_ret__; do { const void *__vpp_verify = (typeof((&(cpu_number)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(cpu_number)) { case 1: pscr_ret__ = ({ typeof(cpu_number) pfo_ret__; switch (sizeof(cpu_number)) { case 1: asm("mov" "b ""%%""gs"":" "%" "1"",%0" : "=q" (pfo_ret__) : "m" (cpu_number)); break; case 2: asm("mov" "w ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 4: asm("mov" "l ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 8: asm("mov" "q ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; default: __bad_percpu_size(); } pfo_ret__; }); break; case 2: pscr_ret__ = ({ typeof(cpu_number) pfo_ret__; switch (sizeof(cpu_number)) { case 1: asm("mov" "b ""%%""gs"":" "%" "1"",%0" : "=q" (pfo_ret__) : "m" (cpu_number)); break; case 2: asm("mov" "w ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 4: asm("mov" "l ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 8: asm("mov" "q ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; default: __bad_percpu_size(); } pfo_ret__; }); break; case 4: pscr_ret__ = ({ typeof(cpu_number) pfo_ret__; switch (sizeof(cpu_number)) { case 1: asm("mov" "b ""%%""gs"":" "%" "1"",%0" : "=q" (pfo_ret__) : "m" (cpu_number)); break; case 2: asm("mov" "w ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 4: asm("mov" "l ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 8: asm("mov" "q ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; default: __bad_percpu_size(); } pfo_ret__; }); break; case 8: pscr_ret__ = ({ typeof(cpu_number) pfo_ret__; switch (sizeof(cpu_number)) { case 1: asm("mov" "b ""%%""gs"":" "%" "1"",%0" : "=q" (pfo_ret__) : "m" (cpu_number)); break; case 2: asm("mov" "w ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 4: asm("mov" "l ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 8: asm("mov" "q ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; default: __bad_percpu_size(); } pfo_ret__; }); break; default: __bad_size_call_parameter(); break; } pscr_ret__; }))), cpu_online_mask))) { rcu_read_lock_sched_notrace(); ({ typeof(*(__tracepoint_net_dev_xmit.funcs)) *________p1 = (typeof(*(__tracepoint_net_dev_xmit.funcs)) *)({ typeof((__tracepoint_net_dev_xmit.funcs)) _________p1 = ({ union { typeof((__tracepoint_net_dev_xmit.funcs)) __val; char __c[1]; } __u; if (1) __read_once_size(&((__tracepoint_net_dev_xmit.funcs)), __u.__c, sizeof((__tracepoint_net_dev_xmit.funcs))); else __read_once_size_nocheck(&((__tracepoint_net_dev_xmit.funcs)), __u.__c, sizeof((__tracepoint_net_dev_xmit.funcs))); __u.__val; }); do { } while (0); (_________p1); }); do { } while (0); ; ((typeof(*(__tracepoint_net_dev_xmit.funcs)) *)(________p1)); }); rcu_read_unlock_sched_notrace(); } } static inline __attribute__((unused)) __attribute__((no_instrument_function)) void trace_net_dev_xmit_rcuidle(struct sk_buff *skb, int rc, struct net_device *dev, unsigned int skb_len) { if (static_key_false(&__tracepoint_net_dev_xmit.key)) do { struct tracepoint_func *it_func_ptr; void *it_func; void *__data; if (!(cpumask_test_cpu(((({ typeof(cpu_number) pscr_ret__; do { const void *__vpp_verify = (typeof((&(cpu_number)) + 0))((void *)0); (void)__vpp_verify; } while (0); switch(sizeof(cpu_number)) { case 1: pscr_ret__ = ({ typeof(cpu_number) pfo_ret__; switch (sizeof(cpu_number)) { case 1: asm("mov" "b ""%%""gs"":" "%" "1"",%0" : "=q" (pfo_ret__) : "m" (cpu_number)); break; case 2: asm("mov" "w ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 4: asm("mov" "l ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 8: asm("mov" "q ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; default: __bad_percpu_size(); } pfo_ret__; }); break; case 2: pscr_ret__ = ({ typeof(cpu_number) pfo_ret__; switch (sizeof(cpu_number)) { case 1: asm("mov" "b ""%%""gs"":" "%" "1"",%0" : "=q" (pfo_ret__) : "m" (cpu_number)); break; case 2: asm("mov" "w ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 4: asm("mov" "l ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 8: asm("mov" "q ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; default: __bad_percpu_size(); } pfo_ret__; }); break; case 4: pscr_ret__ = ({ typeof(cpu_number) pfo_ret__; switch (sizeof(cpu_number)) { case 1: asm("mov" "b ""%%""gs"":" "%" "1"",%0" : "=q" (pfo_ret__) : "m" (cpu_number)); break; case 2: asm("mov" "w ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 4: asm("mov" "l ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 8: asm("mov" "q ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; default: __bad_percpu_size(); } pfo_ret__; }); break; case 8: pscr_ret__ = ({ typeof(cpu_number) pfo_ret__; switch (sizeof(cpu_number)) { case 1: asm("mov" "b ""%%""gs"":" "%" "1"",%0" : "=q" (pfo_ret__) : "m" (cpu_number)); break; case 2: asm("mov" "w ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 4: asm("mov" "l ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; case 8: asm("mov" "q ""%%""gs"":" "%" "1"",%0" : "=r" (pfo_ret__) : "m" (cpu_number)); break; default: __bad_percpu_size(); } pfo_ret__; }); break; default: __bad_size_call_parameter(); break; } pscr_ret__; }))), cpu_online_mask))) return; rcu_irq_enter(); rcu_read_lock_sched_notrace(); it_func_ptr = ({ typeof(*((&__tracepoint_net_dev_xmit)->funcs)) *________p1 = (typeof(*((&__tracepoint_net_dev_xmit)->funcs)) *)({ typeof(((&__tracepoint_net_dev_xmit)->funcs)) _________p1 = ({ union { typeof(((&__tracepoint_net_dev_xmit)->funcs)) __val; char __c[1]; } __u; if (1) __read_once_size(&(((&__tracepoint_net_dev_xmit)->funcs)), __u.__c, sizeof(((&__tracepoint_net_dev_xmit)->funcs))); else __read_once_size_nocheck(&(((&__tracepoint_net_dev_xmit)->funcs)), __u.__c, sizeof(((&__tracepoint_net_dev_xmit)->funcs))); __u.__val; }); do { } while (0); (_________p1); }); do { } while (0); ; ((typeof(*((&__tracepoint_net_dev_xmit)->funcs)) *)(________p1)); }); if (it_func_ptr) { do { it_func = (it_func_ptr)->func; __data = (it_func_ptr)->data; ((void(*)(void *__data, struct sk_buff *skb, int rc, struct net_device *dev, unsigned int skb_len))(it_func))(__data, skb, rc, dev, skb_len); } while ((++it_func_ptr)->func); } rcu_read_unlock_sched_notrace(); rcu_irq_exit(); } while (0); } static inline __attribute__((unused)) __attribute__((no_instrument_function)) int register_trace_net_dev_xmit(void (*probe)(void *__data, struct sk_buff *skb, int rc, struct net_device *dev, unsigned int skb_len), void *data) { return tracepoint_probe_register(&__tracepoint_net_dev_xmit, (void *)probe, data); } static inline __attribute__((unused)) __attribute__((no_instrument_function)) int register_trace_prio_net_dev_xmit(void (*probe)(void *__data, struct sk_buff *skb, int rc, struct net_device *dev, unsigned int skb_len), void *data, int prio) { return tracepoint_probe_register_prio(&__tracepoint_net_dev_xmit, (void *)probe, data, prio); } static inline __attribute__((unused)) __attribute__((no_instrument_function)) int unregister_trace_net_dev_xmit(void (*probe)(void *__data, struct sk_buff *skb, int rc, struct net_device *dev, unsigned int skb_len), void *data) { return tracepoint_probe_unregister(&__tracepoint_net_dev_xmit, (void *)probe, data); } static inline __attribute__((unused)) __attribute__((no_instrument_function)) void check_trace_callback_type_net_dev_xmit(void (*cb)(void *__data, struct sk_buff *skb, int rc, struct net_device *dev, unsigned int skb_len)) { } static inline __attribute__((unused)) __attribute__((no_instrument_function)) bool trace_net_dev_xmit_enabled(void) { return static_key_false(&__tracepoint_net_dev_xmit.key); }
net-traces.i:60793:
static const char __tpstrtab_net_dev_xmit[] __attribute__((section("__tracepoints_strings"))) = "net_dev_xmit";
struct tracepoint __tracepoint_net_dev_xmit __attribute__((section("__tracepoints"))) = { __tpstrtab_net_dev_xmit, { .enabled = { (0) }, .entries = (void *)0UL }, ((void *)0), ((void *)0), ((void *)0) };
static struct tracepoint * const __tracepoint_ptr_net_dev_xmit __attribute__((__used__)) __attribute__((section("__tracepoints_ptrs"))) = &__tracepoint_net_dev_xmit;;
net-traces.i:60885:
struct trace_event_raw_net_dev_xmit {
        struct trace_entry ent;
        void * skbaddr;
        unsigned int len;
        int rc;
        u32 __data_loc_name;
        char __data[0];
};
static struct trace_event_class event_class_net_dev_xmit;; static struct trace_event_call __attribute__((__used__)) __attribute__((__aligned__(4))) event_net_dev_xmit;
net-traces.i:60968:
struct trace_event_data_offsets_net_dev_xmit { u32 name;; };; ;
net-traces.i:61051:
static __attribute__((no_instrument_function)) enum print_line_t trace_raw_output_net_dev_xmit(struct trace_iterator *iter, int flags, struct trace_event *trace_event) { struct trace_seq *s = &iter->seq; struct trace_seq __attribute__((unused)) *p = &iter->tmp_seq; struct trace_event_raw_net_dev_xmit *field; int ret; field = (typeof(field))iter->ent; ret = trace_raw_output_prep(iter, trace_event); if (ret != TRACE_TYPE_HANDLED) return ret; trace_seq_printf(s, "dev=%s skbaddr=%p len=%u rc=%d" "\n", (char *)((void *)field + (field->__data_loc_name & 0xffff)), field->skbaddr, field->len, field->rc); return trace_handle_return(s); } static struct trace_event_functions trace_event_type_funcs_net_dev_xmit = { .trace = trace_raw_output_net_dev_xmit, };; ;
net-traces.i:61134:
static int __attribute__((no_instrument_function)) __attribute__ ((__section__(".init.text"))) __attribute__((__cold__)) __attribute__((no_instrument_function)) __attribute__((indirect_branch("keep"))) trace_event_define_fields_net_dev_xmit(struct trace_event_call *event_call) { struct trace_event_raw_net_dev_xmit field; int ret; ret = trace_define_field(event_call, "void *", "skbaddr", __builtin_offsetof(typeof(field), skbaddr), sizeof(field.skbaddr), (((void *)(-1)) < (void *)1), FILTER_OTHER); if (ret) return ret; ret = trace_define_field(event_call, "unsigned int", "len", __builtin_offsetof(typeof(field), len), sizeof(field.len), (((unsigned int)(-1)) < (unsigned int)1), FILTER_OTHER); if (ret) return ret; ret = trace_define_field(event_call, "int", "rc", __builtin_offsetof(typeof(field), rc), sizeof(field.rc), (((int)(-1)) < (int)1), FILTER_OTHER); if (ret) return ret; ret = trace_define_field(event_call, "__data_loc " "char" "[]", "name", __builtin_offsetof(typeof(field), __data_loc_name), sizeof(field.__data_loc_name), (((char)(-1)) < (char)1), FILTER_OTHER);; return ret; }; ;
net-traces.i:61217:
static inline __attribute__((unused)) __attribute__((no_instrument_function)) __attribute__((no_instrument_function)) int trace_event_get_offsets_net_dev_xmit( struct trace_event_data_offsets_net_dev_xmit *__data_offsets, struct sk_buff *skb, int rc, struct net_device *dev, unsigned int skb_len) { int __data_size = 0; int __attribute__((unused)) __item_length; struct trace_event_raw_net_dev_xmit __attribute__((unused)) *entry; __item_length = (strlen((dev->name) ? (const char *)(dev->name) : "(null)") + 1) * sizeof(char); __data_offsets->name = __data_size + __builtin_offsetof(typeof(*entry), __data); __data_offsets->name |= __item_length << 16; __data_size += __item_length;; return __data_size; }; ;
net-traces.i:61300:
static __attribute__((no_instrument_function))
void trace_event_raw_event_net_dev_xmit(void *__data, struct sk_buff *skb, int rc, struct net_device *dev, unsigned int skb_len)
{
        struct trace_event_file *trace_file = __data;
        struct trace_event_data_offsets_net_dev_xmit __attribute__((unused)) __data_offsets;
        struct trace_event_buffer fbuffer;
        struct trace_event_raw_net_dev_xmit *entry;
        int __data_size;
        if (trace_trigger_soft_disabled(trace_file))
                return;
        __data_size = trace_event_get_offsets_net_dev_xmit(&__data_offsets, skb, rc, dev, skb_len);
        entry = trace_event_buffer_reserve(&fbuffer, trace_file, sizeof(*entry) + __data_size);
        if (!entry)
                return;
        entry->__data_loc_name = __data_offsets.name;
        {
                entry->skbaddr = skb;
                entry->len = skb_len;
                entry->rc = rc;
                strcpy((char *)((void *)entry + (entry->__data_loc_name & 0xffff)), (dev->name) ? (const char *)(dev->name) : "(null)");;;
        }
        trace_event_buffer_commit(&fbuffer);
};
static inline __attribute__((unused)) __attribute__((no_instrument_function)) void ftrace_test_probe_net_dev_xmit(void) { check_trace_callback_type_net_dev_xmit(trace_event_raw_event_net_dev_xmit); };
net-traces.i:61383:
static __attribute__((no_instrument_function)) void perf_trace_net_dev_xmit(void *__data, struct sk_buff *skb, int rc, struct net_device *dev, unsigned int skb_len);; static char print_fmt_net_dev_xmit[] = "\"" "dev=%s skbaddr=%p len=%u rc=%d" "\", " "__get_str(name), REC->skbaddr, REC->len, REC->rc"; static struct trace_event_class __attribute__((__used__)) __attribute__ ((__section__(".ref.data"))) event_class_net_dev_xmit = { .system = str__net__trace_system_name, .define_fields = trace_event_define_fields_net_dev_xmit, .fields = { &(event_class_net_dev_xmit.fields), &(event_class_net_dev_xmit.fields) }, .raw_init = trace_event_raw_init, .probe = trace_event_raw_event_net_dev_xmit, .reg = trace_event_reg, .perf_probe = perf_trace_net_dev_xmit, };; static struct trace_event_call __attribute__((__used__)) event_net_dev_xmit = { .class = &event_class_net_dev_xmit, { .tp = &__tracepoint_net_dev_xmit, }, .event.funcs = &trace_event_type_funcs_net_dev_xmit, .print_fmt = print_fmt_net_dev_xmit, .flags = TRACE_EVENT_FL_TRACEPOINT, }; static struct trace_event_call __attribute__((__used__)) __attribute__((section("_ftrace_events"))) *__event_net_dev_xmit = &event_net_dev_xmit;
net-traces.i:61468:
static __attribute__((no_instrument_function)) void perf_trace_net_dev_xmit(void *__data, struct sk_buff *skb, int rc, struct net_device *dev, unsigned int skb_len) { struct trace_event_call *event_call = __data; struct trace_event_data_offsets_net_dev_xmit __attribute__((unused)) __data_offsets; struct trace_event_raw_net_dev_xmit *entry; struct pt_regs *__regs; u64 __addr = 0, __count = 1; struct task_struct *__task = ((void *)0); struct hlist_head *head; int __entry_size; int __data_size; int rctx; __data_size = trace_event_get_offsets_net_dev_xmit(&__data_offsets, skb, rc, dev, skb_len); head = ({ do { const void *__vpp_verify = (typeof((event_call->perf_events) + 0))((void *)0); (void)__vpp_verify; } while (0); ({ unsigned long tcp_ptr__; asm volatile("add " "%%""gs"":" "%" "1" ", %0" : "=r" (tcp_ptr__) : "m" (this_cpu_off), "0" (event_call->perf_events)); (typeof(*(event_call->perf_events)) *)tcp_ptr__; }); }); if (__builtin_constant_p(!__task) && !__task && hlist_empty(head)) return; __entry_size = ((((__data_size + sizeof(*entry) + sizeof(u32))) + ((typeof((__data_size + sizeof(*entry) + sizeof(u32))))((sizeof(u64))) - 1)) & ~((typeof((__data_size + sizeof(*entry) + sizeof(u32))))((sizeof(u64))) - 1)); __entry_size -= sizeof(u32); entry = perf_trace_buf_prepare(__entry_size, event_call->event.type, &__regs, &rctx); if (!entry) return; perf_fetch_caller_regs(__regs); entry->__data_loc_name = __data_offsets.name; { entry->skbaddr = skb; entry->len = skb_len; entry->rc = rc; strcpy((char *)((void *)entry + (entry->__data_loc_name & 0xffff)), (dev->name) ? (const char *)(dev->name) : "(null)");;; } perf_trace_buf_submit(entry, __entry_size, rctx, __addr, __count, __regs, head, __task); }; static inline __attribute__((unused)) __attribute__((no_instrument_function)) void perf_test_probe_net_dev_xmit(void) { check_trace_callback_type_net_dev_xmit(perf_trace_net_dev_xmit); };
